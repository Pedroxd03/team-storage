import os
import matplotlib.pyplot as plt
import pandas as pd
from scipy.signal import savgol_filter

def main():
    # Obtener la ruta del directorio del script
    script_path = os.path.dirname(os.path.abspath(__file__))

    # Obtener la lista de archivos CSV en el directorio
    csv_files = [f for f in os.listdir(script_path) if f.endswith("battery_data_sustrend_bank_2023-11-14_11-32-36.csv")]

    # Verificar si hay archivos CSV
    if not csv_files:
        print("No se encontraron archivos CSV en el directorio.")
        return

    # Seleccionar el archivo CSV más reciente según la hora de modificación
    latest_csv = max(csv_files, key=lambda x: os.path.getmtime(os.path.join(script_path, x)))

    # Especificar el archivo CSV a leer
    absolute_csv_path = os.path.join(script_path, latest_csv)

    # Leer el archivo CSV
    data_frame = pd.read_csv(absolute_csv_path)
    data_frame['Timestamp'] = pd.to_datetime(data_frame['Timestamp'])

    # Obtener el número de celdas dinámicamente
    N_CELLS = sum("Voltage" in col for col in data_frame.columns)
    
    # Obtener los índices de inicio y fin de cada descarga
    descarga_indices = data_frame[data_frame['Cell 1 Current'] < 0].index

    if len(descarga_indices) == 0:
        print("No hay datos de descarga en el archivo.")
        return

    # Inicializar variables para el primer intervalo de descarga
    inicio_descarga = descarga_indices[0]
    fin_descarga_anterior = descarga_indices[0]

    # Calcular la duración y el momento de inicio y fin de cada intervalo de descarga
    for fin_descarga in descarga_indices[1:]:
        # Verificar si hay un cambio en la secuencia de descargas
        if fin_descarga - fin_descarga_anterior > 1:
            # Calcular la diferencia de tiempo en segundos
            duracion_descarga_segundos = (data_frame['Timestamp'].iloc[fin_descarga_anterior] - data_frame['Timestamp'].iloc[inicio_descarga]).total_seconds()

            # Convertir la duración a horas
            duracion_descarga_horas = duracion_descarga_segundos / 3600

            # Obtener el momento de inicio y fin en formato HH:MM:SS
            inicio_descarga_str = data_frame['Timestamp'].iloc[inicio_descarga].strftime('%H:%M:%S')
            fin_descarga_str = data_frame['Timestamp'].iloc[fin_descarga_anterior].strftime('%H:%M:%S')

            print(f"Descarga: {inicio_descarga_str} hasta {fin_descarga_str} ({duracion_descarga_horas:.2f} horas)")

            # Actualizar variables para el siguiente intervalo
            inicio_descarga = fin_descarga
        fin_descarga_anterior = fin_descarga

    # Obtener los índices de inicio y fin de cada carga (corriente mayor o igual a 2.6 A)
    carga_indices_inicio = data_frame[(data_frame['Cell 1 Current'] >= 2.6) & (data_frame['Cell 1 Current'].shift(1) < 2.6)].index
    carga_indices_fin = data_frame[(data_frame['Cell 1 Current'] >= 2.6) & (data_frame['Cell 1 Current'].shift(-1) < 2.6)].index

    # Combinar índices de inicio y fin de cargas
    carga_indices = sorted(set(carga_indices_inicio) | set(carga_indices_fin))

    if len(carga_indices) == 0:
        print("No hay datos de carga en el archivo.")
        return

    # Inicializar variables para el primer intervalo de carga
    inicio_carga = carga_indices[0]
    fin_carga_anterior = carga_indices[0]

    # Calcular la duración y el momento de inicio y fin de cada intervalo de carga
    for fin_carga in carga_indices[1:]:
        # Verificar si hay un cambio en la secuencia de cargas
        if fin_carga - fin_carga_anterior > 1:
            # Calcular la diferencia de tiempo en segundos
            duracion_carga_segundos = (data_frame['Timestamp'].iloc[fin_carga_anterior] - data_frame['Timestamp'].iloc[inicio_carga]).total_seconds()

            # Convertir la duración a horas
            duracion_carga_horas = duracion_carga_segundos / 3600

            # Obtener el momento de inicio y fin en formato HH:MM:SS
            inicio_carga_str = data_frame['Timestamp'].iloc[inicio_carga].strftime('%H:%M:%S')
            fin_carga_str = data_frame['Timestamp'].iloc[fin_carga_anterior].strftime('%H:%M:%S')

            print(f"Carga: {inicio_carga_str} hasta {fin_carga_str} ({duracion_carga_horas:.2f} horas)")

            # Actualizar variables para el siguiente intervalo
            inicio_carga = fin_carga
        fin_carga_anterior = fin_carga

    # Definir colores para voltaje, corriente y temperatura
    voltage_colors = ['tab:orange', 'tab:cyan', 'tab:green', 'tab:red', 'tab:purple', 'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']
    temperature_colors = ['tab:orange', 'tab:cyan', 'tab:gray', 'tab:pink', 'tab:brown', 'tab:purple', 'tab:red', 'tab:green', 'tab:orange', 'tab:blue']

    # Inicializar la figura y los subplots
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12), sharex=True)

    # Calcular intervalos de tiempo en segundos
    time_intervals = range(len(data_frame))

    # Convertir intervalos de tiempo a horas dividiendo por 3600
    hours = [t / 3600 for t in time_intervals]

    # Graficar el voltaje y la corriente en el primer subplot (ax1)
    for cell_number in range(1, N_CELLS + 1):
        voltage_column = f"Cell {cell_number} Voltage"
        ax1.plot(hours, data_frame[voltage_column], label=f"{voltage_column} (V)", color=voltage_colors[cell_number - 1])

    current_column = f"Cell 1 Current"  # Puedes elegir cualquier celda para la corriente
    ax1_2 = ax1.twinx()
    ax1_2.plot(hours, data_frame[current_column], linestyle='--', label=f"{current_column} (A)", color='tab:red')

    # Configurar etiquetas y título para el primer subplot
    ax1.set_ylabel('Voltage (V)')
    ax1_2.set_ylabel('Current (A)')
    ax1.legend(loc='lower left')
    ax1_2.legend(loc='lower right')
    ax1.set_title('Voltage and current for each cell')

    # Graficar la temperatura en el segundo subplot (ax2)
    for cell_number in range(1, N_CELLS + 1):
        temperature_column = f"Cell {cell_number} Temp"
        temperature_smoothed = savgol_filter(data_frame[temperature_column], window_length=100, polyorder=1)
        ax2.plot(hours, data_frame[temperature_column], label=f"{temperature_column} (°C)", color=temperature_colors[cell_number - 1])

    # Configurar etiquetas y título para el segundo subplot
    ax2.set_xlabel('Time (hours)')
    ax2.set_ylabel('Temperature (°C)')
    ax2.legend(loc='upper right')
    ax2.set_title('Temperature for each cell')

    # Ajustar diseño y guardar el gráfico como una imagen
    plt.tight_layout()
    plt.subplots_adjust(top=0.9, bottom=0.1, hspace=0.3)  # Ajustar la distancia entre la parte superior de los subplots y el borde de la figura, y el espacio vertical entre los subplots
    plt.savefig(absolute_csv_path + "_subplot_plot.png")

    # Mostrar el gráfico
    plt.show()

if __name__ == "__main__":
    main()
